# -*- coding: utf-8 -*-
"""Copy of final_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bii4pU4U9l6TUsddnWz2afKNG_30J63x
"""

import random
import matplotlib.pyplot as plt
import math
import networkx as nx
avg_delay = []

"""# Scenario 4"""

# importing necessary libraries
# networkx is a network analysis library in python
# for visualization of graph matplotlib will be used

for i in range(20):

    # Create an empty graph with no nodes and edges
    G = nx.Graph()

    # Add 100 nodes to the graph
    # the 0th one is the source node while the 99th one is the destination node
    for i in range(100):
        G.add_node(i)

    # as per requirement connecting the source node to only three other nodes
    weight = random.randint(1, 15)
    G.add_edge(0, 1, weight=weight, label=str(weight))
    weight = random.randint(1, 15)
    G.add_edge(0, 2, weight=weight, label=str(weight))
    weight = random.randint(1, 15)
    G.add_edge(0, 3, weight=weight, label=str(weight))
    # and the destination node to other three nodes too
    weight = random.randint(1, 15)
    G.add_edge(96, 99, weight=weight, label=str(weight))
    weight = random.randint(1, 15)
    G.add_edge(97, 99, weight=weight, label=str(weight))
    weight = random.randint(1, 15)
    G.add_edge(98, 99, weight=weight, label=str(weight))

    # Connect the remaining nodes to five other nodes
    for i in range(1, 99):
        for j in range(1, 6):
            neighbors = [n for n in G.neighbors(i)]
            if len(neighbors) < 5:
                weight = random.randint(1, 15)
                G.add_edge(i, i+j, weight=weight, label=str(weight))

    # list of autonomous systems
    autonomous_systems = []

    # Iterate over the ranges of 20 nodes
    for i in range(0, 100, 20):
        # Create a subgraph for the current range of nodes
        asys = G.subgraph(range(i, i+20))
        # Add the subgraph to the list of autonomous systems
        autonomous_systems.append(asys)

    # Print the number of nodes in each autonomous system
    for i, asys in enumerate(autonomous_systems):
        # print(f"Autonomous system {i+1}: {asys.number_of_nodes()} nodes")
        pass

    # source and destination for each autonomous systems are stored in two lists respectively
    # for example source[0] is the source for AS1 and destination[0] is the destination and gateway router for AS1.
    source = [0, 20, 40, 60, 80]
    destination = [19, 39, 59, 79, 99]
    # print("Number of gateway routers:", len(source)+len(destination)-2)

    for i in range(5):
        # Calculate the total number of paths from the source to the destination
        shortest_path = nx.shortest_path(
            autonomous_systems[i], source[i], destination[i])
        # print(f"The shortest path for AS{i+1} is: {shortest_path}")

    # connecting the autonomous systems together
    G = nx.compose_all([autonomous_systems[0], autonomous_systems[1],
                       autonomous_systems[2], autonomous_systems[3], autonomous_systems[4]])
    weight = random.randint(0, 15)
    G.add_edge(19, 20, weight=weight, label=str(weight))
    weight = random.randint(0, 15)
    G.add_edge(39, 40, weight=weight, label=str(weight))
    weight = random.randint(0, 15)
    G.add_edge(59, 60, weight=weight, label=str(weight))
    weight = random.randint(0, 15)
    G.add_edge(79, 80, weight=weight, label=str(weight))

    source_graph = 0
    dest_graph = 99
    shortest_path = nx.shortest_path(G, source_graph, dest_graph)
    # print(f"The shortest path for the whole graph is: {shortest_path}")

    plt.figure(figsize=(30, 30), dpi=80)
    pos = nx.spring_layout(G, k=3/math.sqrt(G.order()), iterations=30)
    # k =5/math.sqrt(G.order())
    # subgraph = G.subgraph(shortest_path)
    d = dict(G.degree)
    edge_labels = nx.get_edge_attributes(G, 'label')
    nx.draw(G, pos, with_labels=True, node_color='r')
    path_edges = list(zip(shortest_path, shortest_path[1:]))
    nx.draw_networkx_nodes(G, pos, nodelist=shortest_path, node_color='b')
    nx.draw_networkx_edges(G, pos, edgelist=path_edges,
                           edge_color='b', width=5, arrows=True)
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
    plt.axis('equal')
    # plt.show()

    # In the above figure you can see 100 nodes connected to each other and divided into five autonomous systems with
    # 20 nodes each.

    # Calculating the number of hops for the optimal path
    for i in range(5):
        num_hops = nx.shortest_path_length(
            autonomous_systems[i], source[i], destination[i])
        # print(f'Number of hops for AS{i+1}: {num_hops}')

    num_hops_graph = nx.shortest_path_length(G, source_graph, dest_graph)
    # print(f'Number of hops for the whole graph G is: {num_hops_graph}')

    link_cost = 0

    # transmitting 5 packets that will traverse from source 0 to the destination 99
    for i in range(5):
        link_cost = 0
        for j in range(num_hops_graph):
            try:
                d = G.get_edge_data(shortest_path[j], shortest_path[j+1])
                link_cost += d.get('weight')
            except:
                pass
        # print("The delay from source to destination is:", link_cost, "ms")

    avg_delay.append(link_cost)
print("List of delay for 20 iterations:", avg_delay)
total_avg_delay = sum(avg_delay)/len(avg_delay)
print("Average Delay:", sum(avg_delay)/len(avg_delay))
# link cost as bandwidth
bandwidth = 1/total_avg_delay
print(f"The link cost as bandwidth: {bandwidth} bits per ms")


